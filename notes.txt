//Thank Vishwas( @CodevolutionWeb) for all this tutorials and sources.
//https://www.youtube.com/watch?v=HH68tHPq7tA&list=PLC3y8-rFHvwjTELCrPrcZlo6blLBUspd2&index=17&ab_channel=Codevolution

1.in this app each page is a component that can be routed in the applicaiton


//start the applicaiton
1.to run the server ----> yarn serve-json
2.to run the client ----> yarn start

3.
useQuery('super-heroes',fetchSuperHeroes,{cacheTime:1000,staleTime:10000})
cacheTime: set the time for store the fetched data in the cache (default is 5 minutes)
staleTime: set the time that how long the data will be keeped as fresh (and after that if we open the component a re-fetch will be required) (default is 0)
//note: cacheTime triggers the isLoading but the stale time doesn't. It triggers the isFetching.

4.useQuery('super-heroes',fetchSuperHeroes,{refetchOnMount:true, refetchOnWindowFocus:true})
 refetchOnMount: the data will be refetch on mount if the data is stale. (default:true)
 -If it is false the query will not fetch on mount.
 -If it is 'always' the query fetch data whether the data is stale or not

refetchOnWindowFocus: the data will be fetch every time the window has focused. (default:true)

5.Polling
useQuery('super-heroes',fetchSuperHeroes,{refetchInterval:2000, refetchIntervalInBackground:true })
refetchInterval: the query will continuously refetch at this frequency in milliseconds.
refetchIntervalInBackground: If set to true, the query will continue to refetch while their tab/window is in the background. Defaults to false.

6.Fetch On Click
First enable the fetch on component mount. useQuery('super-heroes',fetchSuperHeroes,{enabled:false})
Then inside the onClick of a button use 'refetch' function that React query provides us to fetch the data with query.
Vola! That's it!

7. Data Transformation
To select a property from data use 'select' option.
useQuery('super-heroes',fetchSuperHeroes,
      { select: (data) => {
        const heroNames = data.data.map((hero) => hero.name);
        return heroNames;
       }})

After that inside the component we can use heroNames, cause it refers to the original data.

8.Query By inside
First we should be able to create a query key for each hero (['super-hero', heroId])
useQuery(['super-hero', heroId], fetchSuperHero);  in here we can define the query qey as an array and 
give the hero id to it as a second argument.
Secondly we need to chnage the fetch function in order to give it the heroId
const fetchSuperHero = (heroId) => {
 return axios.get(`http://localhost:4000/superHeroes/${heroId}`)
}

export const useSuperHeroData = (heroId) => {
    return useQuery(['super-hero', heroId], () => fetchSuperHero(heroId));
}

but we can do it simpler like that:

const fetchSuperHero = ({ queryKey }) => {
    const heroId = queryKey[1];
    console.log("query key:", queryKey);
    return axios.get(`http://localhost:4000/superHeroes/${heroId}`)
}
export const useSuperHeroData = (heroId) => {
    return useQuery(['super-hero', heroId], fetchSuperHero);
}

because react query provides queryKey to us adn we can destructure the id from it and use it easily.
And we can use the new hook (useSuperHeroData) inside our new page (RQSuperHero)
And don't forget to add the path to the app.js like this:
<Route path='/rq-super-heroes/:heroId' element={<RQSuperHeroPage />} >
</Route>

9. Dynamic Parallel Queries
If we need to fetch some data from the db and it is dynamic, changing data we should use dynamic parallel queries instead of parallel queries.
For that all we need to do is to use 'useQueries' ('not 'useQuery') with ids.
And then we can return the queryResult.

const fetchSuperHero = (heroId) => {
    return axios.get(`http://localhost:4000/superHeroes/${heroId}`);
}

 const queryResults = useQueries( //it returns an array of query results
        heroIds.map((id) => {
            return {
                queryKey: ['super- hero', id],
                queryFn: () => fetchSuperHero(id)
            }
        })
    )
    console.log("query results", queryResults);

10. Dependent Queries
Can be used dependent queries whenever we need to execute queries sequentially (one query is dependent on another query).

first create a query which find the correct user (with e-mail)
secondly by using the chnannelId that belongs to the user create a second query and fetch channel details.

11. Initial Query Data
in the App.js we declerad the queryClient before, so that queryClient instance can access to the query cache
    const queryClient = useQueryClient(); 
    return useQuery(['super-hero', heroId], fetchSuperHero,
        {
            initialData: () => {
                const hero = queryClient.getQueryData('super-heroes')?.data?.find(hero => hero.id === parseInt(heroId)); //get the hero from hero list by id

                if (hero) {
                    return {
                        data: hero
                    }
                } else {
                    return undefined;
                }
            }
        });
}

Now if we open RQ Super Hero page and then go to the a suoer hero's detail page we don't see loading indicator anymore. Cause the datils page has an 
initial query data which comes from RQ Super Hero Page's query. But a background fetching is still proccessed. 

12. Paginated Queries
 Json-server supports paginated parameters. (localhost:4000/colors?_limit=2&_page=4 and etc.)
 configure the fetch function like this:
 const fetchColors = (pageNumber) => {
    return axios.get(`http://localhost:4000/colors?_limit=2&_page=${pageNumber}`);
}
And use a state to hold page number
    const [pageNumber, setPageNumber] = useState(1);
Configure the query key => ['colors', pageNumber]

Add two buttons to move forward and back in the pages
<button onClick={() => setPageNumber(page => page - 1)} disabled={pageNumber === 1}>Previos Page</button>
<button onClick={() => setPageNumber(page => page + 1)} disabled={pageNumber === 4}>Next Page</button>

Thats all!

(A quick note: 
keepPreviousData: query maintain the data from last successfull fetch when the new data is requested even if the query key has changed
it can be usefull when deailing with tables and etc
)

13. Infinite Queries

-We can use getNextPageParam option to hold page params 
   getNextPageParam: (_lastPage, pages) => {
                if (pages.length < 4) {
                    return pages.length + 1
                } else {
                    return undefined //sets hasPage to false
                }
            }
(above 4 is page number)
-And use useInfiniteQuery to fetch with infinite query
   const { data, isLoading, error, isError, hasNextPage, fetchNextPage, isFetching, isFetchingNextPage } = useInfiniteQuery(['colors'], fetchColors,
        {
            getNextPageParam: (_lastPage, pages) => {
                if (pages.length < 4) {
                    return pages.length + 1
                } else {
                    return undefined //sets hasPage to false
                }
            }
        });

   - For the rendering data change data?data.map to data?.page.map  --->
    data?.pages.map((group, index) => {
                    return (
                        <Fragment key={index}>
                            {
                                group.data.map((color) => {
                                    return (
                                        <h2 key={color.id}>
                                            {color.id}-{color.label}
                                        </h2>
                                    )
                                })
                            }
                        </Fragment>
                    )   
                    <---

14. Mutations
(Json-server supports post request)

Use mutations to create, update or delete data (useQuery has a hook named useMutation already )
A query key is optional to useMutation

First create a post request for create a super hero in the same custom hook
const addSuperHero = (hero) => {
    return axios.post("http://localhost:4000/superHeroes", hero);
}
 
Create and export a hook for adding super hero (useAddSuperHeroData) in your custom hook (useSuperHeroesData) for query.

export const useAddSuperHeroData = () => {
    return useMutation(addSuperHero)
}

On the RQSuperHeroesPage define 2 states which holds name and alterEgo of hero
  const [name, setName] = useState('');
  const [alterEgo, setAlterEGo] = useState('');

Use useAddSuperHeroData() here.
  const { mutate: addHero } = useAddSuperHeroData() (if there are multiple mutations ---> mutations: addHero)
  const { mutate } = useAddSuperHeroData() (if there is a single mutation  it can stay like this---> mutations)

create a function to handle adding hero
 const handleAddHeroClick = () => {
    console.log({ name, alterEgo });
    const hero = { name, alterEgo };
    addHero(hero);
  }

Lastly create a button to fire the handleAddHeroClick function
        <button onClick={refetch}>Show Heroes</button>
Volaaa! You can see the new hero after refetch the heros and also in the db.json

15. Query Validation

For example, after we add a super hero we want to show the list of hero be able to update itself.
For that follow these steps:

- use useQueryClient to access releated query key
    const queryClient = useQueryClient();

    in useMutation function add a onSuccess option and inside of it invalidate queiry by this:
            queryClient.invalidateQueries('super-heroes') //by this invalidation react query refetch the 'super-heros' data
After that useAddSuperHeroData function should be like:


export const useAddSuperHeroData = () => {
    const queryClient = useQueryClient();
    return useMutation(addSuperHero, {
        onSuccess: () => { //run after mutation is successfull (invalidate querie's method for achieving that.)
            queryClient.invalidateQueries('super-heroes') //by this invalidation react query refetch the 'super-heros' data
        }
    })
}

And again, that's really all :)


16. Handling Mutation Response

When we create a hero a response returns from the this request and it stores the hero's data.
So it might be usefull to use thie response instead of making a new get request. 

(
    response of the post--->
    {
        "name": "s",
        "alterEgo": "asds",
        "id": 6
    }
)



export const useAddSuperHeroData = () => {
    const queryClient = useQueryClient();
    return useMutation(addSuperHero, {
        onSuccess: (data) => { //data is entire response that turns from post request
            // queryClient.invalidateQueries('super-heroes') //by this invalidation react query refetch the 'super-heros' data
            queryClient.setQueryData('super-heroes',  // //setQueryData updates the query cache
                (oldQueryData) => { // this function automatically receives the all query data (what is present in the query cache) as an argument
                    return {
                        ...oldQueryData,
                        data: [...oldQueryData.data, data.data]
                    }

                })  
        }
    })
}

Sum it up, with this configuration there will be no get request after the mutation

17. Optimistic updates
The aim is to create a hero and update the hero list even before the post request actually fired.
If we click the 'Add hero' button first we see the optimistic update and then a background fetch will be proccessed but from the clientside there will be no change.

For achieving this aim we will use three call back function belongs to the useMutation:
-onMutate: is called before the mutation function is fired and it basically updates the hero list even before the post request.
-onError: access query data and that return from the on mutate call back and sets the old query data as current data when an error occurs
-onSettled: ensure the client state is in sync with the server state

 return useMutation(addSuperHero, {
        onMutate: async (newHero) => { 
            await queryClient.cancelQueries('super-heroes') 
            const previousData = queryClient.getQueryData('super-heroes')
            queryClient.setQueryData('super-heroes', 
                (oldQueryData) => {
                    return {
                        ...oldQueryData,
                        // data: [...oldQueryData.data, newHero.data]
                        data: [
                            ...oldQueryData.data, { id: oldQueryData?.data?.lenght + 1, ...newHero }
                        ],

                    }

                })
        },
        onError: (_error, _hero, context) => {
            queryClient.setQueryData('super-heroes', context.previousData)
        },
        onSettled: () => { 
            queryClient.invalidateQueries('super-heroes') 
        }
    })

18. Axios Interceptor

Create a folder calld utils in the 'src' directory and in it create an axios-utils.js file

In there define a function (maybe named 'request') will wraps the axios request and accepts all the options that axios accepts.
Create an axios client, inside the 'request' function  spread out the axios' opitons, define authorizaiton token, onSucces and onError callbacks.
And eventually return the client.

const client = axios.create({ baseURL: 'http://localhost:4000' }) //an axios client
//baseUrl: our json-server url

export const request = ({ ...options }) => {  // the 'request' function wraps the axios request and accepts all the options that axios accepts
    client.defaults.headers.common.Authorization = `Bearer token`; // now we can find this bearer token in the header
    const onSuccess = (response) => response;
    const onError = (error) => {
        //optionally you can add additional logging here (if there is an error redirect the home page or etc.)
        return error
    }

    return client(options).then(onSuccess).catch(onError);
}


 We can use this interceptor where we make the axios requests before

 get requests changes from this
 const fetchSuperHeroes = () => {
    return axios.get("http://localhost:4000/superHeroes")
}
 to this --->
 const fetchSuperHeroes = () => {
    return request({ url: '/superHeroes' })
}

or for post request:

const addSuperHero = (hero) => {
    return axios.post("http://localhost:4000/superHeroes", hero);
}

--->

const addSuperHero = (hero) => {
    return request({
        url: '/superHeroes', method: 'post', data: hero
    })
}



