//Thank Vishwas( @CodevolutionWeb) for all this tutorials and sources.
//https://www.youtube.com/watch?v=HH68tHPq7tA&list=PLC3y8-rFHvwjTELCrPrcZlo6blLBUspd2&index=17&ab_channel=Codevolution

1.in this app each page is a component that can be routed in the applicaiton


//start the applicaiton
1.to run the server ----> yarn serve-json
2.to run the client ----> yarn start

3.
useQuery('super-heroes',fetchSuperHeroes,{cacheTime:1000,staleTime:10000})
cacheTime: set the time for store the fetched data in the cache (default is 5 minutes)
staleTime: set the time that how long the data will be keeped as fresh (and after that if we open the component a re-fetch will be required) (default is 0)
//note: cacheTime triggers the isLoading but the stale time doesn't. It triggers the isFetching.

4.useQuery('super-heroes',fetchSuperHeroes,{refetchOnMount:true, refetchOnWindowFocus:true})
 refetchOnMount: the data will be refetch on mount if the data is stale. (default:true)
 -If it is false the query will not fetch on mount.
 -If it is 'always' the query fetch data whether the data is stale or not

refetchOnWindowFocus: the data will be fetch every time the window has focused. (default:true)

5.Polling
useQuery('super-heroes',fetchSuperHeroes,{refetchInterval:2000, refetchIntervalInBackground:true })
refetchInterval: the query will continuously refetch at this frequency in milliseconds.
refetchIntervalInBackground: If set to true, the query will continue to refetch while their tab/window is in the background. Defaults to false.

6.Fetch On Click
First enable the fetch on component mount. useQuery('super-heroes',fetchSuperHeroes,{enabled:false})
Then inside the onClick of a button use 'refetch' function that React query provides us to fetch the data with query.
Vola! That's it!

7. Data Transformation
To select a property from data use 'select' option.
useQuery('super-heroes',fetchSuperHeroes,
      { select: (data) => {
        const heroNames = data.data.map((hero) => hero.name);
        return heroNames;
       }})

After that inside the component we can use heroNames, cause it refers to the original data.

8.Query By inside
First we should be able to create a query key for each hero (['super-hero', heroId])
useQuery(['super-hero', heroId], fetchSuperHero);  in here we can define the query qey as an array and 
give the hero id to it as a second argument.
Secondly we need to chnage the fetch function in order to give it the heroId
const fetchSuperHero = (heroId) => {
 return axios.get(`http://localhost:4000/superHeroes/${heroId}`)
}

export const useSuperHeroData = (heroId) => {
    return useQuery(['super-hero', heroId], () => fetchSuperHero(heroId));
}

but we can do it simpler like that:

const fetchSuperHero = ({ queryKey }) => {
    const heroId = queryKey[1];
    console.log("query key:", queryKey);
    return axios.get(`http://localhost:4000/superHeroes/${heroId}`)
}
export const useSuperHeroData = (heroId) => {
    return useQuery(['super-hero', heroId], fetchSuperHero);
}

because react query provides queryKey to us adn we can destructure the id from it and use it easily.
And we can use the new hook (useSuperHeroData) inside our new page (RQSuperHero)
And don't forget to add the path to the app.js like this:
<Route path='/rq-super-heroes/:heroId' element={<RQSuperHeroPage />} >
</Route>

9. Dynamic Parallel Queries
If we need to fetch some data from the db and it is dynamic, changing data we should use dynamic parallel queries instead of parallel queries.
For that all we need to do is to use 'useQueries' ('not 'useQuery') with ids.
And then we can return the queryResult.

const fetchSuperHero = (heroId) => {
    return axios.get(`http://localhost:4000/superHeroes/${heroId}`);
}

 const queryResults = useQueries( //it returns an array of query results
        heroIds.map((id) => {
            return {
                queryKey: ['super- hero', id],
                queryFn: () => fetchSuperHero(id)
            }
        })
    )
    console.log("query results", queryResults);

10. Dependent Queries
Can be used dependent queries whenever we need to execute queries sequentially (one query is dependent on another query).

first create a query which find the correct user (with e-mail)
secondly by using the chnannelId that belongs to the user create a second query and fetch channel details.

11. Initial Query Data
in the App.js we declerad the queryClient before, so that queryClient instance can access to the query cache
    const queryClient = useQueryClient(); 
    return useQuery(['super-hero', heroId], fetchSuperHero,
        {
            initialData: () => {
                const hero = queryClient.getQueryData('super-heroes')?.data?.find(hero => hero.id === parseInt(heroId)); //get the hero from hero list by id

                if (hero) {
                    return {
                        data: hero
                    }
                } else {
                    return undefined;
                }
            }
        });
}

Now if we open RQ Super Hero page and then go to the a suoer hero's detail page we don't see loading indicator anymore. Cause the datils page has an 
initial query data which comes from RQ Super Hero Page's query. But a background fetching is still proccessed. 

12. Paginated Queries
 Json-server supports paginated parameters. (localhost:4000/colors?_limit=2&_page=4 and etc.)
 configure the fetch function like this:
 const fetchColors = (pageNumber) => {
    return axios.get(`http://localhost:4000/colors?_limit=2&_page=${pageNumber}`);
}
And use a state to hold page number
    const [pageNumber, setPageNumber] = useState(1);
Configure the query key => ['colors', pageNumber]

Add two buttons to move forward and back in the pages
<button onClick={() => setPageNumber(page => page - 1)} disabled={pageNumber === 1}>Previos Page</button>
<button onClick={() => setPageNumber(page => page + 1)} disabled={pageNumber === 4}>Next Page</button>

Thats all!

(A quick note: 
keepPreviousData: query maintain the data from last successfull fetch when the new data is requested even if the query key has changed
it can be usefull when deailing with tables and etc
)

13. Infinite Queries

-We can use getNextPageParam option to hold page params 
   getNextPageParam: (_lastPage, pages) => {
                if (pages.length < 4) {
                    return pages.length + 1
                } else {
                    return undefined //sets hasPage to false
                }
            }
(above 4 is page number)
-And use useInfiniteQuery to fetch with infinite query
   const { data, isLoading, error, isError, hasNextPage, fetchNextPage, isFetching, isFetchingNextPage } = useInfiniteQuery(['colors'], fetchColors,
        {
            getNextPageParam: (_lastPage, pages) => {
                if (pages.length < 4) {
                    return pages.length + 1
                } else {
                    return undefined //sets hasPage to false
                }
            }
        });

   - For the rendering data change data?data.map to data?.page.map  --->
    data?.pages.map((group, index) => {
                    return (
                        <Fragment key={index}>
                            {
                                group.data.map((color) => {
                                    return (
                                        <h2 key={color.id}>
                                            {color.id}-{color.label}
                                        </h2>
                                    )
                                })
                            }
                        </Fragment>
                    )   
                    <---

14. Mutations
(Json-server supports post request)

Use mutations to create, update or delete data (useQuery has a hook named useMutation already )
A query key is optional to useMutation

First create a post request for create a super hero in the same custom hook
const addSuperHero = (hero) => {
    return axios.post("http://localhost:4000/superHeroes", hero);
}
 
Create and export a hook for adding super hero (useAddSuperHeroData) in your custom hook (useSuperHeroesData) for query.

export const useAddSuperHeroData = () => {
    return useMutation(addSuperHero)
}

On the RQSuperHeroesPage define 2 states which holds name and alterEgo of hero
  const [name, setName] = useState('');
  const [alterEgo, setAlterEGo] = useState('');

Use useAddSuperHeroData() here.
  const { mutate: addHero } = useAddSuperHeroData() (if there are multiple mutations ---> mutations: addHero)
  const { mutate } = useAddSuperHeroData() (if there is a single mutation  it can stay like this---> mutations)

create a function to handle adding hero
 const handleAddHeroClick = () => {
    console.log({ name, alterEgo });
    const hero = { name, alterEgo };
    addHero(hero);
  }

Lastly create a button to fire the handleAddHeroClick function
        <button onClick={refetch}>Show Heroes</button>
Volaaa! You can see the new hero after refetch the heros and also in the db.json

15. Query Validation

For example, after we add a super hero we want to show the list of hero be able to update itself.
For that follow these steps:

- use useQueryClient to access releated query key
    const queryClient = useQueryClient();

    in useMutation function add a onSuccess option and inside of it invalidate queiry by this:
            queryClient.invalidateQueries('super-heroes') //by this invalidation react query refetch the 'super-heros' data
After that useAddSuperHeroData function should be like:


export const useAddSuperHeroData = () => {
    const queryClient = useQueryClient();
    return useMutation(addSuperHero, {
        onSuccess: () => { //run after mutation is successfull (invalidate querie's method for achieving that.)
            queryClient.invalidateQueries('super-heroes') //by this invalidation react query refetch the 'super-heros' data
        }
    })
}

And again, that's really all :)